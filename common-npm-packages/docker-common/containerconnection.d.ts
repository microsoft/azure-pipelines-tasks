import * as tr from "azure-pipelines-task-lib/toolrunner";
import AuthenticationToken from "./registryauthenticationprovider/registryauthenticationtoken";
export default class ContainerConnection {
    private dockerPath;
    protected hostUrl: string;
    protected certsDir: string;
    private caPath;
    private certPath;
    private keyPath;
    private registryAuth;
    private configurationDirPath;
    private oldDockerConfigContent;
    constructor();
    createCommand(): tr.ToolRunner;
    execCommand(command: tr.ToolRunner, options?: tr.IExecOptions): Q.Promise<never>;
    open(hostEndpoint?: string, authenticationToken?: AuthenticationToken, multipleLoginSupported?: boolean, doNotAddAuthToConfig?: boolean): void;
    getQualifiedImageNameIfRequired(imageName: string): string;
    getQualifiedImageName(repository: string, enforceDockerNamingConvention?: boolean): string;
    getQualifiedImageNamesFromConfig(repository: string, enforceDockerNamingConvention?: boolean): string[];
    close(multipleLoginSupported?: boolean, command?: string): void;
    setDockerConfigEnvVariable(): void;
    unsetDockerConfigEnvVariable(): void;
    private logout();
    private removeConfigDirAndUnsetEnvVariable();
    private unsetEnvironmentVariable();
    private isLogoutRequired(command);
    private openHostEndPoint(hostEndpoint?);
    protected openRegistryEndpoint(authenticationToken?: AuthenticationToken, multipleLoginSupported?: boolean, doNotAddAuthToConfig?: boolean): void;
    private getExistingDockerConfigFilePath();
    private getDockerConfigJson(configurationFilePath);
    private writeDockerConfigJson(dockerConfigContent, configurationFilePath?);
    private getDockerConfigDirPath();
    private ensureDirExists(dirPath);
    private getTempDirectory();
    private getRegistryUrlsFromDockerConfig();
    private isPathInTempDirectory(path);
    private prefixRegistryIfRequired(registry, repository);
}
