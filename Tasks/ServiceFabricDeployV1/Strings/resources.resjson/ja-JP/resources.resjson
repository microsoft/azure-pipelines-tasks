{
  "loc.friendlyName": "Service Fabric アプリケーションの配置",
  "loc.helpMarkDown": "[このタスクの詳細を表示](https://go.microsoft.com/fwlink/?LinkId=820528)",
  "loc.description": "Azure Service Fabric アプリケーションをクラスターにデプロイします",
  "loc.instanceNameFormat": "Service Fabric アプリケーションの展開",
  "loc.group.displayName.advanced": "詳細設定",
  "loc.group.displayName.upgrade": "アップグレード設定",
  "loc.group.displayName.docker": "Docker 設定",
  "loc.input.label.applicationPackagePath": "アプリケーション パッケージ",
  "loc.input.help.applicationPackagePath": "展開されるアプリケーション パッケージへのパス。パスでは [変数](https://go.microsoft.com/fwlink/?LinkID=550988) およびワイルドカードが使用できます。",
  "loc.input.label.serviceConnectionName": "クラスター サービス接続",
  "loc.input.help.serviceConnectionName": "クラスターに接続するために使用される Azure Service Fabric サービス接続を選択します。この参照されたサービス接続で定義された設定は、公開プロファイルで定義されたものをオーバーライドします。[管理] を選択して、新しいサービス接続を登録します。",
  "loc.input.label.publishProfilePath": "発行プロファイル",
  "loc.input.help.publishProfilePath": "使用する設定を定義する公開プロファイル ファイルへのパス。パスでは [変数](https://go.microsoft.com/fwlink/?LinkID=550988) およびワイルドカードが使用できます。",
  "loc.input.label.applicationParameterPath": "アプリケーション パラメーター",
  "loc.input.help.applicationParameterPath": "アプリケーション パラメーター ファイルへのパス。パスでは [変数](https://go.microsoft.com/fwlink/?LinkID=550988) およびワイルドカードが使用できます。これを指定すると、発行プロファイルの値をオーバーライドします。",
  "loc.input.label.overrideApplicationParameter": "アプリケーション パラメーターのオーバーライド",
  "loc.input.help.overrideApplicationParameter": "ビルド パイプラインまたはリリース パイプラインで定義された変数は、アプリケーション マニフェスト ファイル内の 'Parameter Name' エントリと照合されます。\n 例: アプリケーションでパラメーターが次のように定義されていて、\n <Parameters> \n <Parameter Name=\"SampleApp_PartitionCount\" Value=\"1\" /> \n <Parameter Name=\"SampleApp_InstanceCount\" DefaultValue=\"-1\" /> \n </Parameters> \n パーティション数を 2 に変更したい場合、リリース パイプラインを定義するか、環境変数 \"SampleApp_PartitionCount\" とその値 \"2\" を定義することができます。\n\n 注: リリース パイプラインと環境で同じ変数が定義されている場合、環境変数はリリース パイプライン変数よりも優先されます。",
  "loc.input.label.compressPackage": "パッケージの圧縮",
  "loc.input.help.compressPackage": "イメージ ストアにコピーする前にアプリケーション パッケージを圧縮する必要があるかどうかを示します。これを有効にすると、発行プロファイルの値がオーバーライドされます。",
  "loc.input.label.copyPackageTimeoutSec": "CopyPackageTimeoutSec",
  "loc.input.help.copyPackageTimeoutSec": "アプリケーション パッケージのイメージ ストアへのコピーがタイムアウトするまでの秒数。これを指定すると、発行プロファイルの値がオーバーライドされます。",
  "loc.input.label.registerPackageTimeoutSec": "RegisterPackageTimeoutSec",
  "loc.input.help.registerPackageTimeoutSec": "アプリケーション パッケージの登録または登録解除に対するタイムアウト (秒)。",
  "loc.input.label.overwriteBehavior": "上書きの動作",
  "loc.input.help.overwriteBehavior": "上書き動作: アップグレードが構成されておらず、同じ名前のアプリケーションが既にクラスターに存在する場合、次の操作を実行できます: [実行しない]、[常に行う]、[SameAppTypeAndVersion]。\n    [実行しない]   では、既存のアプリケーションは削除されません。これは既定の動作です。\n    [常に行う] では、アプリケーションの種類とバージョンが作成中のアプリケーションと異なる場合でも、既存のアプリケーションが削除されます。\n    [SameAppTypeAndVersion] では、そのアプリケーションの種類とバージョンが作成中のアプリケーションと同じ場合にのみ、既存のアプリケーションが削除されます。",
  "loc.input.label.skipUpgradeSameTypeAndVersion": "同じ種類とバージョンのアップグレードのスキップ",
  "loc.input.help.skipUpgradeSameTypeAndVersion": "同じアプリケーションの種類とバージョンがクラスター内に既に存在する場合に、アップグレードをスキップするか、検証中にアップグレードを失敗させるかを指定します。有効な場合、再配置はべき等になります。",
  "loc.input.label.skipPackageValidation": "パッケージ検証のスキップ",
  "loc.input.help.skipPackageValidation": "配置前にパッケージを検証するかどうかを示します。",
  "loc.input.label.useDiffPackage": "差分パッケージを使用する",
  "loc.input.help.useDiffPackage": "更新済みのアプリケーション ファイル、更新済みのアプリケーション マニフェスト、サービス マニフェスト ファイルのみを含む差分パッケージを使用してアップグレードします。",
  "loc.input.label.overridePublishProfileSettings": "すべての発行プロファイル アップグレード設定をオーバーライドする",
  "loc.input.help.overridePublishProfileSettings": "これはすべてのアップグレード設定を以下の指定された値、または指定されていない場合は既定値でオーバーライドします。",
  "loc.input.label.isUpgrade": "アプリケーションをアップグレードする",
  "loc.input.label.unregisterUnusedVersions": "未使用のバージョンの登録解除",
  "loc.input.help.unregisterUnusedVersions": "アップグレード後に、未使用のバージョンのアプリケーションの種類をすべて削除するかどうかを示します。",
  "loc.input.label.upgradeMode": "アップグレード モード:",
  "loc.input.label.FailureAction": "FailureAction",
  "loc.input.label.UpgradeReplicaSetCheckTimeoutSec": "UpgradeReplicaSetCheckTimeoutSec",
  "loc.input.label.TimeoutSec": "TimeoutSec",
  "loc.input.label.ForceRestart": "ForceRestart",
  "loc.input.label.HealthCheckRetryTimeoutSec": "HealthCheckRetryTimeoutSec",
  "loc.input.label.HealthCheckWaitDurationSec": "HealthCheckWaitDurationSec",
  "loc.input.label.HealthCheckStableDurationSec": "HealthCheckStableDurationSec",
  "loc.input.label.UpgradeDomainTimeoutSec": "UpgradeDomainTimeoutSec",
  "loc.input.label.ConsiderWarningAsError": "ConsiderWarningAsError",
  "loc.input.label.DefaultServiceTypeHealthPolicy": "DefaultServiceTypeHealthPolicy",
  "loc.input.label.MaxPercentUnhealthyDeployedApplications": "MaxPercentUnhealthyDeployedApplications",
  "loc.input.label.UpgradeTimeoutSec": "UpgradeTimeoutSec",
  "loc.input.label.ServiceTypeHealthPolicyMap": "ServiceTypeHealthPolicyMap",
  "loc.input.label.configureDockerSettings": "Docker 設定の構成",
  "loc.input.help.configureDockerSettings": "指定した Docker 設定を使用してアプリケーションを構成します。",
  "loc.input.label.registryCredentials": "レジストリ資格情報のソース",
  "loc.input.help.registryCredentials": "Docker レジストリ用に資格情報を提供する方法を選びます。",
  "loc.input.label.dockerRegistryEndpoint": "Docker レジストリ サービス接続",
  "loc.input.help.dockerRegistryEndpoint": "Docker レジストリ サービス接続を選択します。レジストリでの認証が必要なコマンドで必要です。<br/>注: タスクは、Service Fabric クラスターに送信する前に、レジストリの秘密の暗号化を試行します。しかし、そうするにはクラスターのサーバー証明書がエージェント マシンにインストールされていることが必要です。証明書がない場合、秘密は暗号化されません。",
  "loc.input.label.azureSubscriptionEndpoint": "Azure サブスクリプション",
  "loc.input.help.azureSubscriptionEndpoint": "Azure サブスクリプションを選択します。<br/>注: Service Fabric クラスターに転送する前に、タスクはレジストリ シークレットの暗号化を試みます。しかし、そのためにはクラスターのサーバー証明書がエージェント マシンにインストールされている必要があります。証明書が存在しない場合は、シークレットは暗号化されません。",
  "loc.input.label.registryUserName": "レジストリのユーザー名",
  "loc.input.help.registryUserName": "Docker レジストリのユーザー名",
  "loc.input.label.registryPassword": "レジストリのパスワード",
  "loc.input.help.registryPassword": "Docker レジストリのパスワード。パスワードを暗号化しない場合は、カスタム リリース パイプラインの秘密の変数に格納することをお勧めします。",
  "loc.input.label.passwordEncrypted": "パスワードの暗号化",
  "loc.input.help.passwordEncrypted": "[Invoke-ServiceFabricEncryptText](https://docs.microsoft.com/ja-jp/azure/service-fabric/service-fabric-application-secret-management#encrypt-application-secrets) を使用してパスワードを暗号化することをお勧めします。暗号化せず、クラスター サービス接続内のサーバー証明書の拇印に一致する証明書がビルド エージェントにインストールされている場合は、パスワードを暗号化するためにその証明書が使われます。それ以外の場合は、エラーが発生します。",
  "loc.messages.DIFFPKG_ApplicationDoesNotExist": "diff パッケージを使用してアップグレードするアプリケーション {0} がクラスター {1} に存在しません。配置を実施するために、完全なアプリケーション パッケージを適用しています...",
  "loc.messages.DIFFPKG_ApplicationIsNotChanged": "差分パッケージを使用してアップグレードするアプリケーション {0} の同じバージョン {1} がクラスター {2} で実行されています。アップグレードをスキップします。",
  "loc.messages.DIFFPKG_CopyingToDiffPackge": "完全なアプリケーション パッケージから {0} を差分パッケージの {1} にコピーしています...",
  "loc.messages.DIFFPKG_CreatingDiffPackage": "差分パッケージを作成しようとしています...",
  "loc.messages.DIFFPKG_CreatingDiffPackageForService": "サービス {0}、clusterServiceManifest.Version {1}、localServiceManifest.Version {2} の差分パッケージを作成しています",
  "loc.messages.DIFFPKG_NoServicesRunning": "アプリケーション {0} のサービスはクラスター {1} で実行されていません。現在、完全アプリケーション パッケージを適用して展開を実行しています...",
  "loc.messages.DIFFPKG_PackageDoesNotExist": "パッケージ {0} が完全アプリケーション パッケージに存在していません。差分パッケージへのコピーをスキップします。",
  "loc.messages.DIFFPKG_ServiceDoesNotExist": "差分パッケージを使用してアップグレードするアプリケーション {1} のサービス {0} がクラスター {2} に存在しません。差分パッケージにコピーしています...",
  "loc.messages.DIFFPKG_ServiceIsNotChanged": "差分パッケージを使用してアップグレードするアプリケーション {1} のサービス {0} の同じバージョン {2} がクラスター {3} で実行されています。アップグレードをスキップします。",
  "loc.messages.DIFFPKG_TestAppPkgFailed": "差分パッケージを作成する前のアプリケーション パッケージのテストに失敗しました。差分パッケージの作成をスキップします。",
  "loc.messages.ItemSearchMoreThanOneFound": "検索パターン {0} で複数のアイテムが見つかりました。存在できるのは 1 つだけです。",
  "loc.messages.ItemSearchNoFilesFound": "検索パターン {0} でアイテムが見つかりませんでした。",
  "loc.messages.SearchingForPath": "パスを検索しています: {0}",
  "loc.messages.FoundPath": "見つかったパス: {0}",
  "loc.messages.PathDoesNotExist": "パス {0} が存在しません",
  "loc.messages.EmptyApplicationName": "アプリケーション名には空ではない文字列を指定してください",
  "loc.messages.ServiceEndpointUpgradeWarning": "配置タスクは、大きな変更の可能性のある新しいバージョンにアップグレードされました。サービス接続で定義されたクラスター エンドポイントが以前は無視されましたが、今は公開プロファイル内の値をオーバーライドするようになりました。エンドポイントが正しく、'https://' が先頭に付いていることを確認してください。加えて、サーバー証明書の拇印フィールドがサービス接続に追加され、それも公開プロファイルの値をオーバーライドします。サービス接続は、サーバー証明書の拇印の指定を許可するように更新されていない可能性があり、その場合は公開プロファイルからの値が使用されるままになるため、すぐに再試行する必要があります。",
  "loc.messages.OverrideApplicationParameterFile": "Azure Pipelines タスクで '{0}' が指定された公開プロファイルで指定されたアプリケーション パラメーター ファイルをオーバーライドしています。",
  "loc.messages.OverrideUpgradeSettings": "公開プロファイルで指定されたアップグレード設定を、Azure Pipelines タスクで指定された設定によって上書きしています。",
  "loc.messages.PublishProfileRequiredServerThumbprint": "サービス接続でサーバー証明書の拇印を定義するか、Azure Pipelines タスクで公開プロファイルを指定する必要があります。",
  "loc.messages.PublishProfileRequiredAppParams": "Azure Pipelines タスクにおいて、アプリケーション パラメーター ファイルまたは公開プロファイルを指定する必要があります。",
  "loc.messages.PublishProfileRequiredUpgrade": "Azure Pipelines タスクにおいて、アップグレード設定を上書きするか、または公開プロファイルを指定する必要があります。",
  "loc.messages.UnsupportedARMAuthScheme": "'{0}' は ARM エンドポイントではサポートされていない認証スキームです。",
  "loc.messages.UnsupportedContainerRegistryAuthScheme": "'{0}' は Azure コンテナー レジストリではサポートされていない認証スキームです。",
  "loc.messages.SFSDK_InvalidSFPackage": "{0} は有効な Service Fabric アプリケーション パッケージではありません。",
  "loc.messages.SFSDK_PackageValidationFailed": "パッケージの検証に失敗しました: {0}",
  "loc.messages.SFSDK_UnableToVerifyClusterConnection": "Service Fabric クラスターへのサービス接続を確認できません。",
  "loc.messages.SFSDK_UnableToReadAppTypeAndVersion": "アプリケーションの種類およびバージョンをアプリケーション マニフェスト ファイルから読み取れません。",
  "loc.messages.SFSDK_AppAlreadyExistsError": "'{0}' という名前のアプリケーションは既に存在します。その種類は '{1}' で、バージョンは '{2}' です。新しいアプリケーションを展開する前にまず既存のアプリケーションを削除するか、またはアプリケーションに新しい名前を指定する必要があります。",
  "loc.messages.SFSDK_AppAlreadyExistsInfo": "アプリケーションの種類が '{1}' でバージョンが '{2}' の '{0}' という名前のアプリケーションがクラスター内に既に存在します。削除しています。",
  "loc.messages.SFSDK_UnregisteringExistingAppType": "アプリケーションの種類 '{0}' およびバージョン '{1}' は既にクラスターに登録されています。登録解除しています...",
  "loc.messages.SFSDK_SkipUnregisteringExistingAppType": "アプリケーションの種類 '{0}'、バージョン '{1}' がクラスターに既に登録されていて、現在使用中です。そのため、アプリケーションの種類の登録解除をスキップしています",
  "loc.messages.SFSDK_UnableToUnregisterAppType": "既存のアプリケーションの種類の登録解除に失敗しました。",
  "loc.messages.SFSDK_CopyingAppToImageStore": "アプリケーションをイメージ ストアにコピーしています...",
  "loc.messages.SFSDK_CopyingAppToImageStoreFailed": "アプリケーション パッケージのイメージ ストアへのコピーに失敗しました。アプリケーションの登録を続行できません。",
  "loc.messages.SFSDK_RegisterAppType": "アプリケーションの種類を登録しています...",
  "loc.messages.SFSDK_RegisterAppTypeFailed": "アプリケーションの種類の登録に失敗しました。",
  "loc.messages.SFSDK_RemoveAppPackage": "アプリケーション パッケージをイメージ ストアから削除しています...",
  "loc.messages.SFSDK_CreateApplication": "アプリケーションを作成しています...",
  "loc.messages.SFSDK_CreateApplicationFailed": "アプリケーションの作成に失敗しました。",
  "loc.messages.SFSDK_CreateApplicationSuccess": "アプリケーションの作成に成功しました。",
  "loc.messages.SFSDK_AppDoesNotExist": "アプリケーション '{0}' はクラスター内に存在しません。",
  "loc.messages.SFSDK_AppTypeMismatch": "アプリケーション '{0}' のアプリケーションの種類は、新しいアプリケーション パッケージのアプリケーション マニフェストにおけるアプリケーションの種類と一致しません。アップグレードするアプリケーションが同じアプリケーションの種類のものであることを確認してください。",
  "loc.messages.SFSDK_UpgradeInProgressError": "アプリケーション '{0}' のアップグレードは既に進行中です。",
  "loc.messages.SFSDK_StartAppUpgrade": "アプリケーションのアップグレードを開始します...",
  "loc.messages.SFSDK_StartUpgradeFailed": "アプリケーションのアップグレードを開始できませんでした。エラー {0}。",
  "loc.messages.SFSDK_UnregisterAppTypeOnUpgradeFailure": "アップグレードを正常に開始できませんでした。アプリケーションの種類 '{0}' とバージョン '{1}' の登録を解除しています。",
  "loc.messages.SFSDK_CurrentUpgradeState": "現在のアップグレードの状態:",
  "loc.messages.SFSDK_DomainUpgradeStatus": "ドメインごとのアップグレードの状態:",
  "loc.messages.SFSDK_UnregisterUnusedVersions": "アプリケーションの種類の他の未使用のバージョンを登録解除しています...",
  "loc.messages.SFSDK_UpgradeSuccess": "アップグレードが正常に完了しました。",
  "loc.messages.SFSDK_UpgradeRolledBack": "アップグレードがロール バックされました。",
  "loc.messages.SFSDK_UnzipPackage": "'{0}' を場所 '{1}' に解凍しようとしています。",
  "loc.messages.SFSDK_UnexpectedError": "予期しないエラー。エラーの詳細: $_.Exception.Message",
  "loc.messages.SFSDK_CopyPackageTimeoutSecWarning": "CopyPackageTimeoutSec パラメーターにはバージョン '2.3' の Service Fabric SDK が必要ですが、インストールされているバージョンは '{0}' です。このパラメーターは無視されます。",
  "loc.messages.SFSDK_CompressPackageWarning": "CompressPackage パラメーターにはバージョン '2.5' の Service Fabric SDK が必要ですが、インストールされているバージョンは '{0}' です。このパラメーターは無視されます。",
  "loc.messages.SFSDK_SkipUpgradeWarning": "アプリケーションの種類 '{0}'、バージョン '{1}' はクラスター内に既に存在するため、アップグレードをスキップします。",
  "loc.messages.SFSDK_UnregisterAppTypeFailed": "アプリケーションの種類の登録を解除できませんでした。エラー: {0}。",
  "loc.messages.SFSDK_PerformingForceRemoveOnTimeout": "アプリケーション '{0}' の削除がタイムアウトします。これは、ChangeRole/Close でサービスが停止し、シャットダウン シーケンスが完了できないことを意味しています。アプリケーションの ForceRemove を実行しています。",
  "loc.messages.SFSDK_RetryingCopyApplicationPackage": "アップロードを再試行しています...",
  "loc.messages.SFSDK_RetryingRegisterApplicationType": "登録を再試行しています..",
  "loc.messages.SFSDK_RetryingGetApplicationType": "アプリケーションの種類を取得しています...",
  "loc.messages.SFSDK_ApplicationTypeProvisioningNotStarted": "アプリケーションの種類に対してプロビジョニングが開始されていません。",
  "loc.messages.SFSDK_ApplicationTypeProvisioningStarted": "アプリケーションの種類に対してプロビジョニングが開始されました。完了するのを待っています...",
  "loc.messages.SFSDK_RegisterAppTypeFailedWithStatus": "アプリケーションの種類を登録できませんでした。状態: {0}。詳細: {1}。",
  "loc.messages.SFSDK_ApplicationTypeStatus": "アプリケーションの種類の状態: {0}。詳細: {1}。",
  "loc.messages.SFSDK_ApplicationTypeUnprovisioned": "アプリケーションの種類がプロビジョニングされていません。登録が再試行されます。",
  "loc.messages.SFSDK_ClusterHealth": "クラスターの正常性:",
  "loc.messages.SFSDK_ApplicationTypeUnprovisioningStarted": "アプリケーション タイプに対してプロビジョニングの解除が開始されました。完了するのを待機しています..",
  "loc.messages.SFSDK_UnregisterAppTypeFailedWithStatus": "アプリケーションの種類の登録を解除できませんでした。状態: {0}。詳細: {1}。",
  "loc.messages.SFSDK_RetryingUnregisterApplicationType": "登録の解除を再試行しています..",
  "loc.messages.SFSDK_RetryingRemoveApplication": "アプリケーションの削除を再試行しています..",
  "loc.messages.SFSDK_RetryingCreateApplication": "アプリケーションの作成を再試行しています..",
  "loc.messages.SFSDK_ApplicationHealth": "アプリケーションの正常性を取得しています:",
  "loc.messages.SFSDK_RetryingUpgradeApplication": "アプリケーションのアップグレードを再試行しています..",
  "loc.messages.SFSDK_RetryingGetApplicationUpgrade": "アプリケーションのアップグレードの状態を取得しています...",
  "loc.messages.SFSDK_RetryingGetApplication": "クラスターからアプリケーションを取得しています...",
  "loc.messages.SFSDK_RetryingGetServiceType": "クラスターからサービスの種類を取得しています...",
  "loc.messages.SFSDK_RetryingGetServiceManifest": "クラスターからサービス マニフェストを取得しています...",
  "loc.messages.SFSDK_RetryingTestClusterConnection": "クラスターへの接続をテストしています..",
  "loc.messages.SFSDK_RetryingTestAppPackage": "アプリケーション パッケージをテストしています..",
  "loc.messages.SFSDK_RetryingGetClusterManifest": "クラスター マニフェストを取得しています...",
  "loc.messages.SFSDK_RetryingRemoveApplicationPackage": "アプリケーション パッケージの削除を再試行しています.."
}