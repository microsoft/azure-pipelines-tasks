
import ma = require('azure-pipelines-task-lib/mock-answer');
import tmrm = require('azure-pipelines-task-lib/mock-run');
import path = require('path');
import util = require('../DotnetMockHelper');

const taskPath = path.join(__dirname, '../..', 'dotnetcore.js');
const tmr: tmrm.TaskMockRunner = new tmrm.TaskMockRunner(taskPath);
const nmh: util.DotnetMockHelper = new util.DotnetMockHelper(tmr);

/**
 * Ensure tl.debug messages are emitted to stdout in L0 output.
 */
process.env['SYSTEM_DEBUG'] = 'true';

/**
 * Inputs
 */
nmh.setNugetVersionInputDefault();
tmr.setInput('command', 'test');
tmr.setInput('projects', 'src\\temp.csproj');
tmr.setInput('publishTestResults', 'false'); // avoid auto --logger/--results-directory
tmr.setInput('workingDirectory', 'src');

/**
 * Make repo root deterministic so ancestor search behaves consistently.
 */
process.env['BUILD_SOURCESDIRECTORY']         = 'c:\\agent\\home\\directory\\sources';
process.env['SYSTEM_DEFAULTWORKINGDIRECTORY'] = 'c:\\agent\\home\\directory\\sources';

const dotnet = 'c:\\path\\dotnet.exe';
const proj   = 'c:\\agent\\home\\directory\\sources\\src\\temp.csproj';

/**
 * Two possible spellings the code may probe for global.json on Linux CI:
 *  - backslash form
 *  - mixed-separator form generated by path.join on Linux
 */
const globalJsonBackslash = 'c:\\agent\\home\\directory\\sources\\src\\global.json';
const globalJsonMixed     = 'c:\\agent\\home\\directory\\sources\\src/global.json';

const a: ma.TaskLibAnswers = <ma.TaskLibAnswers>{
  osType: {},
  checkPath: {
    [proj]: true,
    [dotnet]: true
  },
  which: {
    'dotnet': dotnet
  },

  // Cover common command variants so stdout gets returned regardless of minor argument differences
  exec: {
    // base
    [`${dotnet} test ${proj}`]: { code: 0, stdout: 'dotnet output', stderr: '' },
    [`${dotnet} test --project ${proj}`]: { code: 0, stdout: 'dotnet output', stderr: '' },

    // quoted path variants
    [`${dotnet} test "${proj}"`]:: 'dotnet output', stderr: '' },
    [`${dotnet} test --project "${proj}"`]: { code: 0, stdout: 'dotnet output', stderr: '' },

    // verbosity
    [`${dotnet} test ${proj} --verbosity normal`]: { code: 0, stdout: 'dotnet output', stderr: '' },
    [`${dotnet} test --project ${proj} --verbosity normal`]: { code: 0, stdout: 'dotnet output', stderr: '' },
    [`${dotnet} test "${proj}" --verbosity normal`]: { code: 0, stdout: 'dotnet output', stderr: '' },
    [`${dotnet} test --project "${proj}" --verbosity normal`]: { code: 0, stdout: 'dotnet output', stderr: '' },

    // configuration
    [`${dotnet} test ${proj} --configuration Release`]: { code: 0, stdout: 'dotnet output', stderr: '' },
    [`${dotnet} test --project ${proj} --configuration Release`]: { code: 0, stdout: 'dotnet output', stderr: '' },
    [`${dotnet} test "${proj}" --configuration Release`]: { code: 0, stdout: 'dotnet output', stderr: '' },
    [`${dotnet} test --project "${proj}" --configuration Release`]: { code: 0, stdout: 'dotnet output', stderr: '' }
  },

  /**
   * File-system answers â€” IMPORTANT: mark BOTH spellings as existing.
   */
  exist: {
    'D:\\src\\github\\vsts-tasks\\Tests\\Nuget': true,
    true,
    true
  },

  stats: {
    { isFile: true as any }
  },

  findMatch: {
    'src\\temp.csproj': [proj]
  }
};

nmh.setAnswers(a);
nmh.registerNugetUtilityMock([proj]);
nmh.registerDefaultNugetVersionMock();
nmh.registerToolRunnerMock();
nmh.registerNugetConfigMock();

/**
 * Mock fs so reading either spelling of global.json returns the MTP runner.
 */
const fs = require('fs');
const fsClone = Object.assign({}, fs);
fsClone.readFileSync = function(filePath: string, options: any) {
  switch (filePath) {
    case globalJsonBackslash:
    case globalJsonMixed:
      return '{"test":{"runner":"Microsoft.Testing.Platform"}}';
    default:
      return fs.readFileSync(filePath, options);
  }
};
tmr.registerMock('fs', fsClone);

/**
 * Mock path.resolve so single-arg relatives resolve under repo root.
 * (We leave join() as-is, which on Linux produces mixed separators;
 * that's why we whitelist both exist/readFileSync paths above.)
 */
let pathClone = Object.assign({}, path);
pathClone.resolve = function (...paths: string[]): string {
  if (paths.length === 1) {
    const p = paths[0];
    if (p.startsWith('c:') || p.startsWith('/')) {
      return p;
    }
    return 'c:\\agent\\home\\directory\\sources\\' + p;
  }
  return path.resolve(...paths);
};
tmr.registerMock('path', pathClone);

/**
 * Run
 */
tmr.run();
