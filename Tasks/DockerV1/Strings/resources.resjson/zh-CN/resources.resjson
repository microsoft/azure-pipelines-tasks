{
  "loc.friendlyName": "Docker",
  "loc.helpMarkDown": "[详细了解此任务](https://go.microsoft.com/fwlink/?linkid=848006)",
  "loc.description": "生成、标记、推送或运行 Docker 映像，或者运行 Docker 命令",
  "loc.instanceNameFormat": "$(command)",
  "loc.releaseNotes": "通过以下方式简化任务:<br/>&nbsp;- 提供用于简单选择或键入命令的选项。<br/>&nbsp;- 保留有用的输入字段并提供将其余部分作为参数传递给命令的选项。",
  "loc.group.displayName.containerRegistry": "容器注册表",
  "loc.group.displayName.commands": "命令",
  "loc.group.displayName.advanced": "高级选项",
  "loc.input.label.containerregistrytype": "容器注册表类型",
  "loc.input.help.containerregistrytype": "选择“Azure 容器注册表”，可使用 Azure 服务连接来连接它。选择“容器注册表”可连接到 Docker Hub 或任何其他私有容器注册表。",
  "loc.input.label.addBaseImageData": "将基本映像元数据添加到映像",
  "loc.input.help.addBaseImageData": "默认情况下，将添加基本映像数据(如基本映像名称和摘要)，这有助于提升可跟踪性。可以使用此输入选择退出此默认行为。",
  "loc.input.label.dockerRegistryEndpoint": "Docker 注册表服务连接",
  "loc.input.help.dockerRegistryEndpoint": "选择 Docker 注册表服务连接。这对于需要执行注册表身份验证的命令是必需的。",
  "loc.input.label.azureSubscriptionEndpoint": "Azure 订阅",
  "loc.input.help.azureSubscriptionEndpoint": "选择 Azure 订阅",
  "loc.input.label.azureContainerRegistry": "Azure 容器注册表",
  "loc.input.help.azureContainerRegistry": "docker 运行命令首先在指定的映像上创建一个可写容器层，然后使用指定的运行命令启动它。例如，如果映像包含一个简单的 Python Flask Web 应用程序，则可以指定 \"python app.py\" 来启动 Web 应用程序。",
  "loc.input.label.command": "命令",
  "loc.input.help.command": "选择 Docker 命令。",
  "loc.input.label.dockerFile": "Dockerfile",
  "loc.input.help.dockerFile": "Dockerfile 路径。",
  "loc.input.label.arguments": "参数",
  "loc.input.help.arguments": "Docker 命令选项。如果是“标记”命令，可在此处为 Docker 映像指定其他标记。",
  "loc.input.label.pushMultipleImages": "推送多个映像",
  "loc.input.help.pushMultipleImages": "使用包含要推送的 Docker 映像名称的文本文件来推送多个映像。每个映像名称都包含在自己的行中。<br>例如:<br>  Imagename1:tag1<br>  Imagename2:tag2<br>  Imagename3<br>如果仅提供映像名称，将推送 ImageName3 容器映像的所有标记。",
  "loc.input.label.tagMultipleImages": "标记多个映像",
  "loc.input.help.tagMultipleImages": "使用包含要标记的 Docker 映像名称的文本文件标记多个映像。每个映像名称都包含在自己的行中。<br>例如:<br>  Imagename1:tag1<br>  Imagename2:tag2<br>  Imagename3<br>如果仅提供映像名称，该映像将被标记为 \"latest\"。",
  "loc.input.label.imageName": "映像名",
  "loc.input.help.imageName": "要生成、推送或运行的 Docker 映像的名称。",
  "loc.input.label.imageNamesPath": "映像名称路径",
  "loc.input.help.imageNamesPath": "文本文件路径，该文件中包含 tag 或 push 的 Docker 映像名称。每个映像名称包含在其自己的行上。",
  "loc.input.label.qualifyImageName": "指定映像名",
  "loc.input.help.qualifyImageName": "如果没有另行指定，请使用 Docker 注册表服务连接的主机名限定映像名称。",
  "loc.input.label.qualifySourceImageName": "指定源映像名称",
  "loc.input.help.qualifySourceImageName": "如果没有另行指定，请使用 Docker 注册表服务连接的主机名限定源映像名称。",
  "loc.input.label.includeSourceTags": "包括源标记",
  "loc.input.help.includeSourceTags": "生成或推送 Docker 映像时包括 Git 标记。",
  "loc.input.label.includeLatestTag": "包括最新的标记",
  "loc.input.help.includeLatestTag": "生成 Docker 映像时包含 \"latest\" 标记。",
  "loc.input.label.addDefaultLabels": "添加默认标签",
  "loc.input.help.addDefaultLabels": "使用 Docker 标签将 CI/CD 元数据(如存储库、提交、生成和发布信息)添加到容器映像中。",
  "loc.input.label.useDefaultContext": "使用默认的生成上下文",
  "loc.input.help.useDefaultContext": "将生成上下文设置为包含 Dockerfile 的目录。",
  "loc.input.label.buildContext": "生成上下文",
  "loc.input.help.buildContext": "生成上下文的路径。",
  "loc.input.label.imageDigestFile": "映像摘要文件",
  "loc.input.help.imageDigestFile": "使用已推送的 Docker 映像的完整映像存储库摘要创建和填充的文件路径。",
  "loc.input.label.containerName": "容器名",
  "loc.input.help.containerName": "要运行的 Docker 容器的名称。",
  "loc.input.label.ports": "端口",
  "loc.input.help.ports": "Docker 容器中要发布到主机的端口。在新的一行指定每个 host-port:container-port 绑定。",
  "loc.input.label.volumes": "卷",
  "loc.input.help.volumes": "从主机装入的卷。在新的一行指定每个 host-dir:container-dir。",
  "loc.input.label.envVars": "环境变量",
  "loc.input.help.envVars": "Docker 容器的环境变量。在新的一行指定每个名称=值对。",
  "loc.input.label.workingDirectory": "工作目录",
  "loc.input.help.workingDirectory": "Docker 容器的工作目录。",
  "loc.input.label.entrypointOverride": "入口点重写",
  "loc.input.help.entrypointOverride": "替代 Docker 容器的默认入口点。",
  "loc.input.label.containerCommand": "容器命令",
  "loc.input.help.containerCommand": "docker 运行命令首先在指定的映像上创建一个可写容器层，然后使用指定的运行命令启动它。例如，如果映像包含一个简单的 Python Flask Web 应用程序，则可以指定“python app.py”来启动 Web 应用程序。",
  "loc.input.label.runInBackground": "后台运行",
  "loc.input.help.runInBackground": "在后台运行 Docker 容器。",
  "loc.input.label.restartPolicy": "重启策略",
  "loc.input.help.restartPolicy": "选择重启策略。",
  "loc.input.label.maxRestartRetries": "最大重启次数",
  "loc.input.help.maxRestartRetries": "Docker 守护程序进行重新启动尝试的最大次数。",
  "loc.input.label.dockerHostEndpoint": "Docker 主机服务连接",
  "loc.input.help.dockerHostEndpoint": "选择 Docker 主机服务连接。默认为代理的主机。",
  "loc.input.label.enforceDockerNamingConvention": "强制映像名称遵循 Docker 命名约定",
  "loc.input.help.enforceDockerNamingConvention": "如果已启用，将修改 Docker 映像名称以遵循 Docker 命名约定。将大写字符转换为小写并删除映像名称中的空格。",
  "loc.input.label.memoryLimit": "内存限制",
  "loc.input.help.memoryLimit": "容器可用的最大内存量，格式为整数后跟可选后缀，如 \"2GB\"。",
  "loc.messages.ConnectingToDockerHost": "已设置 DOCKER_HOST 变量。Docker 将尝试连接到 Docker 主机: %s",
  "loc.messages.ContainerPatternFound": "Docker 文件路径参数中找到的模式",
  "loc.messages.ContainerPatternNotFound": "Docker 文件路径参数中未找到任何模式",
  "loc.messages.ContainerDockerFileNotFound": "找不到匹配 %s 的任何 Dockerfile。",
  "loc.messages.DockerHostVariableWarning": "已设置 DOCKER_HOST 变量。请确保 Docker 守护程序正在 %s 上运行",
  "loc.messages.NoImagesInImageNamesFile": "文件“%s”中至少应有一个映像名称。",
  "loc.messages.CantWriteDataToFile": "无法将数据写入文件 %s。错误: %s",
  "loc.messages.NoDataWrittenOnFile": "没有任何数据写入到文件 %s",
  "loc.messages.FileContentSynced": "文件内容已同步到磁盘。内容为 %s。",
  "loc.messages.DockerRegistryNotFound": "未指定 Docker 注册表服务连接。",
  "loc.messages.OutputVariableDataSizeExceeded": "未设置为 Docker 命令输出的输出变量超出了支持的最大长度。输出长度: %s，支持的最大长度: %s",
  "loc.messages.WritingDockerConfigToTempFile": "正在将 Docker 配置写入临时文件。文件路径: %s，Docker 配置: %s"
}