{
  "loc.friendlyName": "Déployer sur Kubernetes",
  "loc.helpMarkDown": "[En savoir plus sur cette tâche](https://go.microsoft.com/fwlink/?linkid=851275) ou [consulter la documentation de Kubernetes](https://kubernetes.io/docs/home/)",
  "loc.description": "Utiliser les fichiers manifeste Kubernetes pour effectuer un déploiement sur des clusters, ou préparer les fichiers manifeste aux déploiements à l'aide de charts Helm",
  "loc.instanceNameFormat": "$(action)",
  "loc.input.label.action": "Action",
  "loc.input.help.action": "Choisissez l'action à effectuer.",
  "loc.input.label.connectionType": "Type de connexion de service",
  "loc.input.help.connectionType": "Sélectionnez un type de connexion de service.",
  "loc.input.label.kubernetesServiceEndpoint": "Connexion de service Kubernetes",
  "loc.input.help.kubernetesServiceEndpoint": "Sélectionnez une connexion au service Kubernetes.",
  "loc.input.label.azureSubscriptionEndpoint": "Abonnement Azure",
  "loc.input.help.azureSubscriptionEndpoint": "Sélectionnez l'abonnement Azure Resource Manager, qui contient Azure Container Registry. Remarque : Pour configurer une nouvelle connexion de service, sélectionnez l'abonnement Azure dans la liste, puis cliquez sur Autoriser. Remarque : Si votre abonnement n'est pas listé, ou si vous souhaitez utiliser un principal du service existant, vous pouvez configurer une connexion au service Azure à l'aide du bouton 'Ajouter' ou 'Gérer'.",
  "loc.input.label.azureResourceGroup": "Groupe de ressources",
  "loc.input.help.azureResourceGroup": "Sélectionnez un groupe de ressources Azure.",
  "loc.input.label.kubernetesCluster": "Cluster Kubernetes",
  "loc.input.help.kubernetesCluster": "Sélectionnez un cluster managé Azure.",
  "loc.input.label.namespace": "Espace de noms",
  "loc.input.help.namespace": "Définit l'espace de noms des commandes à l'aide de l'indicateur –namespace. Si vous n'indiquez pas l'espace de noms, les commandes sont exécutées dans l'espace de noms par défaut.",
  "loc.input.label.strategy": "Stratégie",
  "loc.input.help.strategy": "Stratégie de déploiement à utiliser",
  "loc.input.label.trafficSplitMethod": "Méthode de division du trafic",
  "loc.input.help.trafficSplitMethod": "Méthode de division du trafic à utiliser",
  "loc.input.label.percentage": "Pourcentage",
  "loc.input.help.percentage": "Pourcentage de redirection du trafic vers le déploiement de contrôle de validité",
  "loc.input.label.baselineAndCanaryReplicas": "Réplicas de base de référence et de contrôle de validité",
  "loc.input.help.baselineAndCanaryReplicas": "Nombre de réplicas de base de référence et de contrôle de validité",
  "loc.input.label.manifests": "Manifestes",
  "loc.input.help.manifests": "Manifestes à déployer",
  "loc.input.label.containers": "Conteneurs",
  "loc.input.help.containers": "Conteneurs",
  "loc.input.label.imagePullSecrets": "ImagePullSecrets",
  "loc.input.help.imagePullSecrets": "ImagePullSecret pour effectuer le tirage (pull) d'une image à partir d'un registre privé",
  "loc.input.label.renderType": "Moteur de rendu",
  "loc.input.help.renderType": "Outil à utiliser pour générer les fichiers manifeste.",
  "loc.input.label.dockerComposeFile": "Chemin du fichier Docker Compose",
  "loc.input.help.dockerComposeFile": "chemin du fichier docker-compose",
  "loc.input.label.helmChart": "Chart Helm",
  "loc.input.help.helmChart": "Chemin du chart Helm à préparer",
  "loc.input.label.releaseName": "Nom de version release Helm",
  "loc.input.help.releaseName": "Nom de version release Helm à utiliser",
  "loc.input.label.overrideFiles": "Fichiers de remplacement",
  "loc.input.help.overrideFiles": "Fichiers de remplacement à définir",
  "loc.input.label.overrides": "Remplacements",
  "loc.input.help.overrides": "Valeurs de remplacement à définir",
  "loc.input.label.kustomizationPath": "Chemin de Kustomization",
  "loc.input.help.kustomizationPath": "L'argument doit être le chemin du répertoire contenant le fichier, ou une URL de dépôt GIT avec un suffixe de chemin spécifiant la même chose par rapport à la racine du dépôt.",
  "loc.input.label.resourceToPatch": "Ressource à corriger",
  "loc.input.help.resourceToPatch": "pour identifier la ressource",
  "loc.input.label.resourceFileToPatch": "Chemin du fichier",
  "loc.input.help.resourceFileToPatch": "Chemin du fichier utilisé pour le correctif",
  "loc.input.label.kind": "Genre",
  "loc.input.help.kind": "Genre d'objet K8s : deployment, replicaSet etc.",
  "loc.input.label.name": "Nom",
  "loc.input.help.name": "Nom de l'objet k8s",
  "loc.input.label.replicas": "Nombre de réplicas",
  "loc.input.help.replicas": "Nombre de réplicas scalables",
  "loc.input.label.mergeStrategy": "Stratégie de fusion",
  "loc.input.help.mergeStrategy": "Type de correctif fourni : parmi [json merge strategic]",
  "loc.input.label.arguments": "Arguments",
  "loc.input.help.arguments": "Arguments de la commande 'kubectl delete'",
  "loc.input.label.patch": "Patch",
  "loc.input.help.patch": "Contenu du correctif",
  "loc.input.label.secretType": "Type de secret",
  "loc.input.help.secretType": "Créez/mettez à jour un imagepullsecret générique ou Docker. Sélectionnez dockerRegistry pour créer/mettre à jour le imagepullsecret du registre sélectionné. Un imagePullSecret permet de passer un secret qui contient un mot de passe de registre de conteneurs au Kubelet afin qu'il puisse tirer (pull) une image privée pour le compte de votre pod.",
  "loc.input.label.secretName": "Nom du secret",
  "loc.input.help.secretName": "Nom du secret. Vous pouvez utiliser le nom de ce secret dans le fichier config YAML de Kubernetes.",
  "loc.input.label.secretArguments": "Arguments",
  "loc.input.help.secretArguments": "Spécifiez les clés et les valeurs littérales à insérer dans le secret. Par exemple, --from-literal=clé1=valeur1 --from-literal=clé2=\"top secret\".",
  "loc.input.label.dockerRegistryEndpoint": "Connexion de service de registre Docker",
  "loc.input.help.dockerRegistryEndpoint": "Sélectionnez une connexion de service de registre Docker. Obligatoire pour les commandes qui doivent s'authentifier après d'un registre.",
  "loc.input.label.rolloutStatusTimeout": "Délai d'expiration de l'état de lancement",
  "loc.input.help.rolloutStatusTimeout": "Délai (en secondes) d'attente avant la fin de la surveillance de l'état de lancement",
  "loc.messages.DownloadPathForStableTxt": "Chemin de téléchargement de stable.txt : %s",
  "loc.messages.DownloadKubeCtlFailed": "Impossible de télécharger le client kubectl de la version %s. Vérifiez si la version est correcte : https://github.com/kubernetes/kubernetes/releases",
  "loc.messages.DownloadStableVersionFailed": "Impossible de télécharger le fichier de la version stable de kubernetes à partir de %s. Retour à %s",
  "loc.messages.DockerComposeFilePathNotSupplied": "chemin du fichier docker-compose non fourni",
  "loc.messages.UsingLatestStableVersion": "Une version 1.7 non valide a été spécifiée dans l'entrée de spécification de version. Utilisation de la dernière version stable à la place. Recherchez les versions appropriées https://github.com/kubernetes/kubernetes/releases",
  "loc.messages.NotAValidSemverVersion": "Version non spécifiée au format approprié. Exemple : 1.8.2, v1.8.2, 2.8.2, v2.8.2.",
  "loc.messages.ManifestFileNotFound": "Le ou les fichiers manifeste correspondant à %s sont introuvables.",
  "loc.messages.KubernetesServiceConnectionNotFound": "Les détails de la connexion de service Kubernetes sont introuvables.",
  "loc.messages.UnknownRenderType": "Moteur de rendu inconnu",
  "loc.messages.ResourceKindNotDefined": "Le genre de la ressource a une valeur null",
  "loc.messages.NullInputObject": "L'objet d'entrée a une valeur null.",
  "loc.messages.ArgumentsInputNotSupplied": "Les arguments ne sont pas fournis.",
  "loc.messages.NullInputObjectMetadata": "Les métadonnées d'objet d'entrée ont une valeur null.",
  "loc.messages.InvalidRejectActionDeploymentStrategy": "L'action de rejet fonctionne uniquement avec la stratégie suivante : contrôle de validité",
  "loc.messages.InvalidPromotetActionDeploymentStrategy": "L'action de promotion fonctionne uniquement avec la stratégie suivante : contrôle de validité",
  "loc.messages.AllContainersNotInReadyState": "Tous les conteneurs ne sont pas prêts.",
  "loc.messages.CouldNotDeterminePodStatus": "Impossible de déterminer l'état du pod en raison de l'erreur %s",
  "loc.messages.KubectlShouldBeUpgraded": "une version du client kubectl égale ou postérieure à la version 1.14 est nécessaire pour utiliser les fonctionnalités de kustomize.",
  "loc.messages.KubernetesClusterResourceGroup": "Cluster Kubernetes : %s, groupe de ressources : %s.",
  "loc.messages.CouldNotDetermineServiceStatus": "Impossible de déterminer l'état du service %s en raison de l'erreur %s",
  "loc.messages.waitForServiceIpAssignment": "En attente d'affectation d'adresse IP externe du service %s",
  "loc.messages.waitForServiceIpAssignmentTimedOut": "Expiration du délai d'attente pour l'affectation d'adresse IP externe du service %s",
  "loc.messages.ServiceExternalIP": "l'adresse IP externe du service %s est %s",
  "loc.messages.UnableToCreateTrafficSplitManifestFile": "Impossible de créer le fichier manifeste TrafficSplit. %s",
  "loc.messages.StableSpecSelectorNotExist": "La ressource %s n'est pas déployée à l'aide du déploiement de contrôle de validité SMI.",
  "loc.messages.InvalidPercentage": "Valeur non valide pour le pourcentage.",
  "loc.messages.InvalidBaselineAndCanaryReplicas": "Valeur non valide pour le nombre de réplicas.",
  "loc.messages.InvalidTimeoutValue": "Valeur non valide pour le délai d'expiration. Entrez un nombre valide.",
  "loc.messages.RolloutStatusTimedout": "Échec de la vérification de l'état de lancement.",
  "loc.messages.EnvironmentLink": "Pour plus d'informations, accédez à %s"
}